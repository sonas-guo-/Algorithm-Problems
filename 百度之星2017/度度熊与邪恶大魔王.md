# 题目链接
度度熊与邪恶大魔王[]
# 思路

# 代码
	#define MAXN 100005
	#define MAXM 1005
	#define LIFE 1005
	#define DEFENCE 15
	int A[MAXN], B[MAXN];
	int K[MAXM], P[MAXM];
	int f[LIFE][DEFENCE];
	int g[LIFE][DEFENCE];
	int main() {
	#ifdef DEBUG
		ifstream cin("in.txt");
		ofstream cout("out.txt");
		//freopen("in.txt", "r", stdin);
		//freopen("out.txt", "w", stdout);
	#endif
		int N, M,damage;
		while (cin>>N>>M)
		{
			for (size_t i = 0; i < N; i++)
				cin >> A[i] >> B[i];
			for (size_t i = 1; i <= M; i++)
				cin >> K[i] >> P[i];
			
			fill_n(g[0], LIFE*DEFENCE, INT_MAX);
			for (int i = 0; i < DEFENCE; i++)
				g[0][i] = 0;
			for (int k = 1; k <= M; k++)
			{
				fill_n(f[0], LIFE*DEFENCE, INT_MAX);

				for (int i = 0; i < LIFE; i++)
				{
					for (int j = 0; j < DEFENCE; j++)
					{
						damage = P[k] - j;
						f[i][j] = min(f[i][j], g[i][j]);
						if (damage > 0)
						{
							if (i - damage >= 0)
								f[i][j] = min(f[i][j], f[i - damage][j] + K[k]);
							else
								f[i][j] = min(f[i][j], f[0][j] + K[k]);
						}
					}
				}
				for (int i = 0; i < LIFE; i++)
					for (int j = 0; j < DEFENCE; j++)
						g[i][j] = f[i][j];
			}
			int64_t ans = 0;
			for (int i = 0; i < N; i++)
			{
				if (f[A[i]][B[i]]!=INT_MAX)
					ans += f[A[i]][B[i]];
				else
				{
					ans = -1;
					break;
				}
			}
			cout << ans << endl;
		}
		return 0;
	}